<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C.A.R.E. 3D Radar Dashboard</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }

        .main-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            background: #2a2a2a;
            border-right: 2px solid #444;
            padding: 20px;
            overflow-y: auto;
        }

        .viewport {
            flex: 1;
            position: relative;
            background: #111;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #444;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
            color: #4CAF50;
        }

        .header p {
            font-size: 0.9rem;
            color: #aaa;
        }

        .status-panel {
            background: #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .status-panel h3 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-online { background-color: #4CAF50; }
        .status-warning { background-color: #FF9800; }
        .status-danger { background-color: #F44336; }
        .status-offline { background-color: #666; }

        .emergency-panel {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white;
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            animation: emergencyBlink 1s infinite;
        }

        .emergency-panel.active {
            display: block;
        }

        @keyframes emergencyBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.7; }
        }

        .targets-panel {
            background: #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .targets-panel h3 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .target-item {
            background: #444;
            border-radius: 5px;
            padding: 8px;
            margin-bottom: 5px;
            font-size: 0.8rem;
        }

        .target-coords {
            color: #aaa;
            font-size: 0.75rem;
        }

        .controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(42, 42, 42, 0.9);
            border-radius: 8px;
            padding: 15px;
            min-width: 200px;
        }

        .controls-panel h4 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #ccc;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 5px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #333;
            color: #fff;
            font-size: 0.9rem;
        }

        .connection-status {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .connection-connected {
            background: #4CAF50;
            color: white;
        }

        .connection-disconnected {
            background: #F44336;
            color: white;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: #444;
            border-radius: 5px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4CAF50;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 2px;
        }

        .fov-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(42, 42, 42, 0.9);
            border-radius: 8px;
            padding: 10px;
            font-size: 0.9rem;
        }

        .fov-indicator h4 {
            color: #4CAF50;
            margin-bottom: 5px;
        }

        #radar3d {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
        <div class="header">
                <h1>ğŸ›¡ï¸ C.A.R.E.</h1>
                <p>3D Radar Dashboard</p>
        </div>

        <div class="emergency-panel" id="emergencyPanel">
                <h2>ğŸš¨ EMERGENCY STOP</h2>
                <p>Safety violation detected!</p>
        </div>

            <div class="status-panel">
                <h3>ğŸ“Š System Status</h3>
                <div class="status-item">
                    <span><span class="status-indicator status-offline"></span>Status:</span>
                    <span id="systemStatus">Unknown</span>
                </div>
                <div class="status-item">
                    <span>Uptime:</span>
                    <span id="systemUptime">0s</span>
                </div>
                <div class="status-item">
                    <span>Messages:</span>
                    <span id="canMessages">0</span>
                </div>
                <div class="status-item">
                    <span>Errors:</span>
                    <span id="systemErrors">0</span>
                </div>
            </div>

            <div class="status-panel">
                <h3>ğŸ›¡ï¸ Safety Status</h3>
                <div class="status-item">
                    <span><span class="status-indicator status-offline"></span>Emergency Stop:</span>
                    <span id="emergencyStopStatus">Inactive</span>
                </div>
                <div class="status-item">
                    <span>Min Distance:</span>
                    <span id="minDistance">500mm</span>
            </div>
                <div class="status-item">
                    <span>Active Targets:</span>
                    <span id="activeTargets">0</span>
                    </div>
                <div class="status-item">
                    <span>Last Trigger:</span>
                    <span id="lastTrigger">Never</span>
                </div>
            </div>

            <div class="targets-panel">
                <h3>ğŸ¯ Active Targets</h3>
                <div id="targetList">
                    <div style="color: #666; text-align: center; padding: 20px;">
                        No targets detected
                    </div>
                </div>
            </div>

            <div class="status-panel">
                <h3>ğŸ“ˆ Performance</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="messagesPerSecond">0</div>
                        <div class="stat-label">Msg/sec</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="averageLatency">0</div>
                        <div class="stat-label">Latency (ms)</div>
                    </div>
                    </div>
                </div>
            </div>

        <!-- 3D Viewport -->
        <div class="viewport">
            <div class="connection-status" id="connectionStatus">
                <span id="connectionText">Connecting...</span>
            </div>

            <div class="controls-panel">
                <h4>ğŸ® View Controls</h4>
                <div class="control-group">
                    <label>View Mode:</label>
                    <select id="viewMode">
                        <option value="radar">Radar View</option>
                        <option value="top">Top View</option>
                        <option value="side">Side View</option>
                        <option value="free">Free Camera</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Range (m):</label>
                    <input type="range" id="rangeSlider" min="1" max="6" value="6" step="1">
                    <span id="rangeValue">6m</span>
                </div>
                <div class="control-group">
                    <label>Show Grid:</label>
                    <input type="checkbox" id="showGrid" checked>
                </div>
                <div class="control-group">
                    <label>Show FOV:</label>
                    <input type="checkbox" id="showFOV" checked>
                    <small style="color: #888;">Single Radar System (0Â°)</small>
                </div>
                <div class="control-group">
                    <label>Show Trails:</label>
                    <input type="checkbox" id="showTrails" checked>
                    <small style="color: #888;">Target movement trails</small>
                </div>
            </div>

            <div class="fov-indicator">
                <h4>ğŸ“ Field of View (Single Radar System)</h4>
                <div>Radar: <span id="fovHorizontal">0Â°</span></div>
                <div>Horizontal FOV: <span id="fovVertical">Â±60Â°</span></div>
                <div>Vertical FOV: <span id="fovVerticalRange">Â±35Â°</span></div>
                <div>Range: <span id="fovRange">6m</span></div>
            </div>

            <div id="radar3d"></div>
        </div>
    </div>

    <script>
        // Simple OrbitControls implementation
        class SimpleOrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.enableDamping = true;
                this.dampingFactor = 0.05;
                this.minDistance = 2;
                this.maxDistance = 60;
                this.target = new THREE.Vector3();

                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();

                // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ spherical Ğ¿Ğ¾ÑĞ»Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ĞºĞ°Ğ¼ĞµÑ€Ñ‹
                this.updateSpherical();

                this.isMouseDown = false;
                this.mouseX = 0;
                this.mouseY = 0;

                this.setupEventListeners();
                this.update();
            }

            setupEventListeners() {
                this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.domElement.addEventListener('wheel', this.onWheel.bind(this));
            }

            onMouseDown(event) {
                this.isMouseDown = true;
                this.mouseX = event.clientX;
                this.mouseY = event.clientY;
            }

            onMouseMove(event) {
                if (!this.isMouseDown) return;

                const deltaX = event.clientX - this.mouseX;
                const deltaY = event.clientY - this.mouseY;

                this.sphericalDelta.theta -= deltaX * 0.01;
                this.sphericalDelta.phi -= deltaY * 0.01;

                this.mouseX = event.clientX;
                this.mouseY = event.clientY;

                this.update();
            }

            onMouseUp(event) {
                this.isMouseDown = false;
            }

            onWheel(event) {
                const delta = event.deltaY * 0.001;
                this.spherical.radius += delta;
                this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
                this.update();
            }

            updateSpherical() {
                const position = this.camera.position.clone().sub(this.target);
                this.spherical.setFromVector3(position);
            }

            update() {
                this.spherical.theta += this.sphericalDelta.theta;
                this.spherical.phi += this.sphericalDelta.phi;
                this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));

                if (this.enableDamping) {
                    this.sphericalDelta.theta *= (1 - this.dampingFactor);
                    this.sphericalDelta.phi *= (1 - this.dampingFactor);
                } else {
                    this.sphericalDelta.set(0, 0, 0);
                }

                const position = new THREE.Vector3();
                position.setFromSpherical(this.spherical);
                position.add(this.target);

                this.camera.position.copy(position);
                this.camera.lookAt(this.target);
            }
        }

        class Care3DDashboard {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.ws = null;
                this.reconnectInterval = null;
                this.targets = [];
                this.targetTrails = []; // Ğ¨Ğ»ĞµĞ¹Ñ„Ñ‹ Ñ†ĞµĞ»ĞµĞ¹
                this.trailLength = 5; // ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ‚Ğ¾Ñ‡ĞµĞº Ğ² ÑˆĞ»ĞµĞ¹Ñ„Ğµ
                this.trailOpacity = 0.6; // ĞŸÑ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ ÑˆĞ»ĞµĞ¹Ñ„Ğ°
                this.radarRange = 6; // 6 Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ² Ğ´Ğ»Ñ FOV

                this.init3D();
                this.initControls();
                this.connect();
                this.animate();
            }

            init3D() {
                const container = document.getElementById('radar3d');

                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x111111);

                // Camera
                this.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000); // FOV Ğ´Ğ»Ñ Ğ»ÑƒÑ‡ÑˆĞµĞ³Ğ¾ Ğ¾Ğ±Ğ·Ğ¾Ñ€Ğ° HLK-LD2450
                this.camera.position.set(0, 5, 10);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(this.renderer.domElement);

                // Controls
                this.controls = new SimpleOrbitControls(this.camera, this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // Create radar elements
                this.createRadarGrid();
                this.createFOV();
                this.createCoordinateAxes();

                // Handle resize
                window.addEventListener('resize', () => this.onWindowResize());
            }

            createRadarGrid() {
                const gridSize = 12; // 12Ğ¼ - Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ñ‡ĞµĞ¼ FOV (6Ğ¼) Ğ´Ğ»Ñ Ğ»ÑƒÑ‡ÑˆĞµĞ³Ğ¾ Ğ¾Ğ±Ğ·Ğ¾Ñ€Ğ°
                const gridDivisions = 12; // 1Ğ¼ Ğ´ĞµĞ»ĞµĞ½Ğ¸Ñ
                const grid = new THREE.GridHelper(gridSize, gridDivisions, 0x444444, 0x222222);
                grid.position.y = 0;
                grid.name = 'radarGrid';
                this.scene.add(grid);
            }

        createFOV() {
            // ĞĞ• Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ•Ğœ ConeGeometry - Ğ¾Ğ½Ğ° ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼
            // Ğ’Ğ¼ĞµÑÑ‚Ğ¾ ÑÑ‚Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾Ğ¹ ÑĞµĞºÑ‚Ğ¾Ñ€ Ğ¸Ğ· Ğ»Ğ¸Ğ½Ğ¸Ğ¹ Ğ½Ğ° Ğ¿Ğ»Ğ¾ÑĞºĞ¾ÑÑ‚Ğ¸ XZ

            // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ³Ñ€Ğ°Ğ´ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºÑƒ Ğ¸ Ğ´ÑƒĞ³Ğ¸ FOV
            this.createFOVBoundaryLines();
            this.createFOVArcs();
            this.createSafetyZone();
        }


        createCoordinateAxes() {
            const axesHelper = new THREE.AxesHelper(2);
            axesHelper.name = 'coordinateAxes';
            this.scene.add(axesHelper);

            // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ 4 Ğ¶ĞµĞ»Ñ‚Ñ‹Ğµ Ğ»Ğ¸Ğ½Ğ¸Ğ¸ Ñ€Ğ°Ğ´Ğ°Ñ€Ğ¾Ğ² Ğ½Ğ° Ğ°Ğ·Ğ¸Ğ¼ÑƒÑ‚Ğ°Ñ… 0Â°, 90Â°, 180Â°, 270Â°
            this.createRadarLines();
        }

        createRadarLines() {
            // 4 Ğ¶ĞµĞ»Ñ‚Ñ‹Ğµ Ğ»Ğ¸Ğ½Ğ¸Ğ¸ Ñ€Ğ°Ğ´Ğ°Ñ€Ğ¾Ğ² Ğ½Ğ° Ğ°Ğ·Ğ¸Ğ¼ÑƒÑ‚Ğ°Ñ… 0Â°, 90Â°, 180Â°, 270Â° Ğ´Ğ»Ğ¸Ğ½Ğ¾Ğ¹ 1Ğ¼
            const radarMaterial = new THREE.LineBasicMaterial({
                color: 0xffff00, // Ğ–ĞµĞ»Ñ‚Ñ‹Ğ¹ Ñ†Ğ²ĞµÑ‚
                transparent: true,
                opacity: 0.9,
                linewidth: 3
            });

            const radarLength = 1.0; // 1 Ğ¼ĞµÑ‚Ñ€

            // Ğ’Ğ¡Ğ• Ğ›Ğ˜ĞĞ˜Ğ˜ ĞĞĞ§Ğ˜ĞĞĞ®Ğ¢Ğ¡Ğ¯ Ğ˜Ğ— Ğ¦Ğ•ĞĞ¢Ğ Ğ (0, 0, 0)
            // Ğ Ğ°Ğ´Ğ°Ñ€ 0Â° (Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ +Z)
            const radar0Points = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, radarLength)
            ];
            const radar0Geometry = new THREE.BufferGeometry().setFromPoints(radar0Points);
            const radar0Line = new THREE.Line(radar0Geometry, radarMaterial);
            radar0Line.name = 'radarLine_0';
            this.scene.add(radar0Line);

            // Ğ Ğ°Ğ´Ğ°Ñ€ 90Â° (Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ +X)
            const radar90Points = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(radarLength, 0, 0)
            ];
            const radar90Geometry = new THREE.BufferGeometry().setFromPoints(radar90Points);
            const radar90Line = new THREE.Line(radar90Geometry, radarMaterial);
            radar90Line.name = 'radarLine_90';
            this.scene.add(radar90Line);

            // Ğ Ğ°Ğ´Ğ°Ñ€ 180Â° (Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ -Z)
            const radar180Points = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -radarLength)
            ];
            const radar180Geometry = new THREE.BufferGeometry().setFromPoints(radar180Points);
            const radar180Line = new THREE.Line(radar180Geometry, radarMaterial);
            radar180Line.name = 'radarLine_180';
            this.scene.add(radar180Line);

            // Ğ Ğ°Ğ´Ğ°Ñ€ 270Â° (Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ -X)
            const radar270Points = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(-radarLength, 0, 0)
            ];
            const radar270Geometry = new THREE.BufferGeometry().setFromPoints(radar270Points);
            const radar270Line = new THREE.Line(radar270Geometry, radarMaterial);
            radar270Line.name = 'radarLine_270';
            this.scene.add(radar270Line);
        }

        createFOVBoundaryLines() {
            // Ğ“ĞĞ Ğ˜Ğ—ĞĞĞ¢ĞĞ›Ğ¬ĞĞĞ¯ Ğ³Ñ€Ğ°Ğ´ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ°: ĞšĞ ĞĞ¡ĞĞ«Ğ• Ğ»Ğ¸Ğ½Ğ¸Ğ¸
            const redSolidMaterial = new THREE.LineBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8,
                linewidth: 3
            });

            const redDashedMaterial = new THREE.LineDashedMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8,
                linewidth: 2,
                dashSize: 0.3,
                gapSize: 0.2
            });

            // Ğ’Ğ•Ğ Ğ¢Ğ˜ĞšĞĞ›Ğ¬ĞĞĞ¯ Ğ³Ñ€Ğ°Ğ´ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ°: Ğ¡Ğ˜ĞĞ˜Ğ• Ğ»Ğ¸Ğ½Ğ¸Ğ¸
            const blueSolidMaterial = new THREE.LineBasicMaterial({
                color: 0x0088ff,
                transparent: true,
                opacity: 0.8,
                linewidth: 2
            });

            const blueDashedMaterial = new THREE.LineDashedMaterial({
                color: 0x0088ff,
                transparent: true,
                opacity: 0.8,
                linewidth: 2,
                dashSize: 0.3,
                gapSize: 0.2
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Ğ“ĞĞ Ğ˜Ğ—ĞĞĞ¢ĞĞ›Ğ¬ĞĞ«Ğ™ FOV: Ğ¾Ñ‚ 300Â° Ğ´Ğ¾ 60Â° (Ñ‡ĞµÑ€ĞµĞ· 0Â°)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Ğ“Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹: ÑĞ¿Ğ»Ğ¾ÑˆĞ½Ñ‹Ğµ ĞºÑ€Ğ°ÑĞ½Ñ‹Ğµ 6Ğ¼ Ğ½Ğ° 300Â° Ğ¸ 60Â°
            this.createHorizontalFOVLine(300, 6, redSolidMaterial, false, 'hFOV_300');
            this.createHorizontalFOVLine(60, 6, redSolidMaterial, false, 'hFOV_60');

            // Ğ—ĞµĞ»ĞµĞ½Ğ°Ñ Ğ³Ñ€Ğ°Ğ´ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 10Â° Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ FOV (ÑĞ¿Ğ»Ğ¾ÑˆĞ½Ñ‹Ğµ Ğ·ĞµĞ»ĞµĞ½Ñ‹Ğµ Ğ»Ğ¸Ğ½Ğ¸Ğ¸ 6Ğ¼)
            const greenSolidMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00, // Ğ—ĞµĞ»ĞµĞ½Ñ‹Ğ¹
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });

            // ĞÑ‚ 300Â° Ğ´Ğ¾ 360Â° (0Â°): 310Â°, 320Â°, 330Â°, 340Â°, 350Â°
            this.createHorizontalFOVLine(310, 6, greenSolidMaterial, false, 'hFOV_310');
            this.createHorizontalFOVLine(320, 6, greenSolidMaterial, false, 'hFOV_320');
            this.createHorizontalFOVLine(330, 6, greenSolidMaterial, false, 'hFOV_330');
            this.createHorizontalFOVLine(340, 6, greenSolidMaterial, false, 'hFOV_340');
            this.createHorizontalFOVLine(350, 6, greenSolidMaterial, false, 'hFOV_350');
            // ĞÑ‚ 0Â° Ğ´Ğ¾ 60Â°: 10Â°, 20Â°, 30Â°, 40Â°, 50Â°
            this.createHorizontalFOVLine(10, 6, greenSolidMaterial, false, 'hFOV_10');
            this.createHorizontalFOVLine(20, 6, greenSolidMaterial, false, 'hFOV_20');
            this.createHorizontalFOVLine(30, 6, greenSolidMaterial, false, 'hFOV_30');
            this.createHorizontalFOVLine(40, 6, greenSolidMaterial, false, 'hFOV_40');
            this.createHorizontalFOVLine(50, 6, greenSolidMaterial, false, 'hFOV_50');

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Ğ’Ğ•Ğ Ğ¢Ğ˜ĞšĞĞ›Ğ¬ĞĞ«Ğ™ FOV: Ğ¾Ñ‚ -35Â° Ğ´Ğ¾ +35Â° Ğ¿Ğ¾ Ğ°Ğ·Ğ¸Ğ¼ÑƒÑ‚Ñƒ 0Â°
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Ğ“Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹: ÑĞ¿Ğ»Ğ¾ÑˆĞ½Ñ‹Ğµ ÑĞ¸Ğ½Ğ¸Ğµ 6Ğ¼ Ğ½Ğ° Â±35Â°
            this.createVerticalFOVLine(0, 35, 6, blueSolidMaterial, false, 'vFOV_0_35');
            this.createVerticalFOVLine(0, -35, 6, blueSolidMaterial, false, 'vFOV_0_-35');

            // Ğ“Ñ€Ğ°Ğ´ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 10Â°: ÑĞ¿Ğ»Ğ¾ÑˆĞ½Ñ‹Ğµ ÑĞ¸Ğ½Ğ¸Ğµ 6Ğ¼
            this.createVerticalFOVLine(0, 30, 6, blueSolidMaterial, false, 'vFOV_0_30');
            this.createVerticalFOVLine(0, -30, 6, blueSolidMaterial, false, 'vFOV_0_-30');
            this.createVerticalFOVLine(0, 20, 6, blueSolidMaterial, false, 'vFOV_0_20');
            this.createVerticalFOVLine(0, -20, 6, blueSolidMaterial, false, 'vFOV_0_-20');
            this.createVerticalFOVLine(0, 10, 6, blueSolidMaterial, false, 'vFOV_0_10');
            this.createVerticalFOVLine(0, -10, 6, blueSolidMaterial, false, 'vFOV_0_-10');

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ»Ğ¸Ğ½Ğ¸Ğ¸ Ğ½Ğ° Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ°Ğ·Ğ¸Ğ¼ÑƒÑ‚Ğ°Ñ… (90Â°, 180Â°, 270Â°)
            // ĞŸÑƒĞ½ĞºÑ‚Ğ¸Ñ€Ğ½Ñ‹Ğµ ÑĞ¸Ğ½Ğ¸Ğµ 3Ğ¼ Ğ½Ğ° Â±35Â°
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            this.createVerticalFOVLine(90, 35, 3, blueDashedMaterial, true, 'vFOV_90_35');
            this.createVerticalFOVLine(90, -35, 3, blueDashedMaterial, true, 'vFOV_90_-35');
            this.createVerticalFOVLine(180, 35, 3, blueDashedMaterial, true, 'vFOV_180_35');
            this.createVerticalFOVLine(180, -35, 3, blueDashedMaterial, true, 'vFOV_180_-35');
            this.createVerticalFOVLine(270, 35, 3, blueDashedMaterial, true, 'vFOV_270_35');
            this.createVerticalFOVLine(270, -35, 3, blueDashedMaterial, true, 'vFOV_270_-35');
        }

        createHorizontalFOVLine(azimuthDegrees, length, material, isDashed, name) {
            const azimuthRadians = Math.PI * azimuthDegrees / 180;
            const points = [];

            // Ğ’Ğ¡Ğ• Ğ›Ğ˜ĞĞ˜Ğ˜ ĞĞĞ§Ğ˜ĞĞĞ®Ğ¢Ğ¡Ğ¯ Ğ˜Ğ— Ğ¦Ğ•ĞĞ¢Ğ Ğ (0, 0, 0)
            for (let i = 0; i <= 20; i++) {
                const distance = length * i / 20;
                points.push(new THREE.Vector3(
                    Math.sin(azimuthRadians) * distance,
                    0,
                    Math.cos(azimuthRadians) * distance
                ));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = isDashed ? new THREE.Line(geometry, material) : new THREE.Line(geometry, material);

            if (isDashed) {
                line.computeLineDistances(); // ĞĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ´Ğ»Ñ LineDashedMaterial
            }

            line.name = name;
            this.scene.add(line);
        }

        createVerticalFOVLine(azimuthDegrees, pitchDegrees, length, material, isDashed, name) {
            const azimuthRadians = Math.PI * azimuthDegrees / 180;
            const pitchRadians = Math.PI * pitchDegrees / 180;
            const points = [];

            // Ğ’Ğ¡Ğ• Ğ›Ğ˜ĞĞ˜Ğ˜ ĞĞĞ§Ğ˜ĞĞĞ®Ğ¢Ğ¡Ğ¯ Ğ˜Ğ— Ğ¦Ğ•ĞĞ¢Ğ Ğ (0, 0, 0)
            for (let i = 0; i <= 20; i++) {
                const distance = length * i / 20;
                points.push(new THREE.Vector3(
                    Math.sin(azimuthRadians) * Math.cos(pitchRadians) * distance,
                    Math.sin(pitchRadians) * distance,
                    Math.cos(azimuthRadians) * Math.cos(pitchRadians) * distance
                ));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = isDashed ? new THREE.Line(geometry, material) : new THREE.Line(geometry, material);

            if (isDashed) {
                line.computeLineDistances(); // ĞĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ´Ğ»Ñ LineDashedMaterial
            }

            line.name = name;
            this.scene.add(line);
        }

        createFOVArcs() {
            // Ğ“ĞĞ Ğ˜Ğ—ĞĞĞ¢ĞĞ›Ğ¬ĞĞĞ¯ Ğ”Ğ£Ğ“Ğ: Ğ—ĞµĞ»ĞµĞ½Ğ°Ñ Ğ´ÑƒĞ³Ğ° Ğ¾Ñ‚ 300Â° Ğ´Ğ¾ 60Â° Ğ½Ğ° Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¸ 6Ğ¼
            const horizontalArcMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00, // Ğ—ĞµĞ»ĞµĞ½Ñ‹Ğ¹
                transparent: true,
                opacity: 0.8,
                linewidth: 3
            });

            const horizontalArcPoints = [];
            const arcRadius = 6; // 6 Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²
            const startAngle = Math.PI * 300 / 180;

            // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ´ÑƒĞ³Ñƒ Ğ¾Ñ‚ 300Â° Ğ´Ğ¾ 60Â° Ñ‡ĞµÑ€ĞµĞ· 0Â°
            const segments = 60;
            for (let i = 0; i <= segments; i++) {
                let angle = startAngle + (Math.PI * 2 / 3) * i / segments;
                horizontalArcPoints.push(new THREE.Vector3(
                    Math.sin(angle) * arcRadius,
                    0,
                    Math.cos(angle) * arcRadius
                ));
            }

            const horizontalArcGeometry = new THREE.BufferGeometry().setFromPoints(horizontalArcPoints);
            const horizontalArc = new THREE.Line(horizontalArcGeometry, horizontalArcMaterial);
            horizontalArc.name = 'horizontalFOVArc';
            this.scene.add(horizontalArc);

            // Ğ’Ğ•Ğ Ğ¢Ğ˜ĞšĞĞ›Ğ¬ĞĞĞ¯ Ğ”Ğ£Ğ“Ğ: Ğ¡Ğ¸Ğ½ÑÑ Ğ´ÑƒĞ³Ğ° Ğ¾Ñ‚ -35Â° Ğ´Ğ¾ +35Â° Ğ½Ğ° Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¸ 6Ğ¼ Ğ¿Ğ¾ Ğ°Ğ·Ğ¸Ğ¼ÑƒÑ‚Ñƒ 0Â°
            const verticalArcMaterial = new THREE.LineBasicMaterial({
                color: 0x0088ff, // Ğ¡Ğ¸Ğ½Ğ¸Ğ¹
                transparent: true,
                opacity: 0.8,
                linewidth: 3
            });

            const verticalArcPoints = [];
            const pitchStart = -35 * Math.PI / 180;
            const pitchEnd = 35 * Math.PI / 180;
            const azimuth0 = 0; // ĞĞ·Ğ¸Ğ¼ÑƒÑ‚ 0Â° (Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ +Z)

            for (let i = 0; i <= segments; i++) {
                const pitch = pitchStart + (pitchEnd - pitchStart) * i / segments;
                verticalArcPoints.push(new THREE.Vector3(
                    Math.sin(azimuth0) * Math.cos(pitch) * arcRadius,
                    Math.sin(pitch) * arcRadius,
                    Math.cos(azimuth0) * Math.cos(pitch) * arcRadius
                ));
            }

            const verticalArcGeometry = new THREE.BufferGeometry().setFromPoints(verticalArcPoints);
            const verticalArc = new THREE.Line(verticalArcGeometry, verticalArcMaterial);
            verticalArc.name = 'verticalFOVArc';
            this.scene.add(verticalArc);
        }

        createSafetyZone() {
            // Safety Ğ·Ğ¾Ğ½Ğ° Ğ¸Ğ· Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ğ»ĞµÑ€Ğ° (Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ 0.5Ğ¼ = 500Ğ¼Ğ¼)
            this.safetyDistance = 0.5; // Ğ¼ĞµÑ‚Ñ€Ñ‹

            const safetyMaterial = new THREE.LineBasicMaterial({
                color: 0xffff00, // Ğ–ĞµĞ»Ñ‚Ñ‹Ğ¹
                transparent: true,
                opacity: 0.9,
                linewidth: 4
            });

            // Ğ“ĞĞ Ğ˜Ğ—ĞĞĞ¢ĞĞ›Ğ¬ĞĞĞ¯ SAFETY Ğ”Ğ£Ğ“Ğ: Ğ¾Ñ‚ 300Â° Ğ´Ğ¾ 60Â° Ğ½Ğ° safety distance
            const hSafetyArcPoints = [];
            const startAngle = Math.PI * 300 / 180;
            const segments = 60;

            for (let i = 0; i <= segments; i++) {
                let angle = startAngle + (Math.PI * 2 / 3) * i / segments;
                hSafetyArcPoints.push(new THREE.Vector3(
                    Math.sin(angle) * this.safetyDistance,
                    0,
                    Math.cos(angle) * this.safetyDistance
                ));
            }

            const hSafetyArcGeometry = new THREE.BufferGeometry().setFromPoints(hSafetyArcPoints);
            const hSafetyArc = new THREE.Line(hSafetyArcGeometry, safetyMaterial);
            hSafetyArc.name = 'horizontalSafetyArc';
            this.scene.add(hSafetyArc);

            // Ğ’Ğ•Ğ Ğ¢Ğ˜ĞšĞĞ›Ğ¬ĞĞĞ¯ SAFETY Ğ”Ğ£Ğ“Ğ: Ğ¾Ñ‚ -35Â° Ğ´Ğ¾ +35Â° Ğ¿Ğ¾ Ğ°Ğ·Ğ¸Ğ¼ÑƒÑ‚Ñƒ 0Â° Ğ½Ğ° safety distance
            const vSafetyArcPoints = [];
            const pitchStart = -35 * Math.PI / 180;
            const pitchEnd = 35 * Math.PI / 180;
            const azimuth0 = 0;

            for (let i = 0; i <= segments; i++) {
                const pitch = pitchStart + (pitchEnd - pitchStart) * i / segments;
                vSafetyArcPoints.push(new THREE.Vector3(
                    Math.sin(azimuth0) * Math.cos(pitch) * this.safetyDistance,
                    Math.sin(pitch) * this.safetyDistance,
                    Math.cos(azimuth0) * Math.cos(pitch) * this.safetyDistance
                ));
            }

            const vSafetyArcGeometry = new THREE.BufferGeometry().setFromPoints(vSafetyArcPoints);
            const vSafetyArc = new THREE.Line(vSafetyArcGeometry, safetyMaterial);
            vSafetyArc.name = 'verticalSafetyArc';
            this.scene.add(vSafetyArc);
        }


            initControls() {
                // View mode selector
                document.getElementById('viewMode').addEventListener('change', (e) => {
                    this.setViewMode(e.target.value);
                });

                // Range slider
                const rangeSlider = document.getElementById('rangeSlider');
                const rangeValue = document.getElementById('rangeValue');
                rangeSlider.addEventListener('input', (e) => {
                    this.radarRange = parseFloat(e.target.value);
                    rangeValue.textContent = `${this.radarRange}m`;
                    this.updateFOV();
                });

                // Grid toggle
                document.getElementById('showGrid').addEventListener('change', (e) => {
                    const grid = this.scene.getObjectByName('radarGrid');
                    if (grid) grid.visible = e.target.checked;
                });

                // FOV toggle
            document.getElementById('showFOV').addEventListener('change', (e) => {
                const horizontalFOV = this.scene.getObjectByName('horizontalFOV');

                if (horizontalFOV) horizontalFOV.visible = e.target.checked;

                // Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒÑ Ğ²ÑĞµÑ… Ğ»Ğ¸Ğ½Ğ¸Ğ¹ FOV
                const fovLines = [
                    // Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹ (ĞºÑ€Ğ°ÑĞ½Ñ‹Ğµ)
                    'hFOV_300', 'hFOV_60',
                    // Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ·ĞµĞ»ĞµĞ½Ğ°Ñ Ğ³Ñ€Ğ°Ğ´ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 10Â°
                    'hFOV_310', 'hFOV_320', 'hFOV_330', 'hFOV_340', 'hFOV_350',
                    'hFOV_10', 'hFOV_20', 'hFOV_30', 'hFOV_40', 'hFOV_50',
                    // Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹ Ğ¸ Ğ³Ñ€Ğ°Ğ´ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¿Ğ¾ Ğ°Ğ·Ğ¸Ğ¼ÑƒÑ‚Ñƒ 0Â° (ÑĞ¸Ğ½Ğ¸Ğµ)
                    'vFOV_0_35', 'vFOV_0_-35', 'vFOV_0_30', 'vFOV_0_-30',
                    'vFOV_0_20', 'vFOV_0_-20', 'vFOV_0_10', 'vFOV_0_-10',
                    // Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ½Ğ° Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ°Ğ·Ğ¸Ğ¼ÑƒÑ‚Ğ°Ñ… (ÑĞ¸Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ½ĞºÑ‚Ğ¸Ñ€Ğ½Ñ‹Ğµ)
                    'vFOV_90_35', 'vFOV_90_-35', 'vFOV_180_35', 'vFOV_180_-35',
                    'vFOV_270_35', 'vFOV_270_-35'
                ];
                fovLines.forEach(lineName => {
                    const line = this.scene.getObjectByName(lineName);
                    if (line) line.visible = e.target.checked;
                });

                // Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒÑ Ğ´ÑƒĞ³ FOV
                const fovArcs = ['horizontalFOVArc', 'verticalFOVArc'];
                fovArcs.forEach(arcName => {
                    const arc = this.scene.getObjectByName(arcName);
                    if (arc) arc.visible = e.target.checked;
                });

                // Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒÑ Safety Ğ´ÑƒĞ³
                const safetyArcs = ['horizontalSafetyArc', 'verticalSafetyArc'];
                safetyArcs.forEach(arcName => {
                    const arc = this.scene.getObjectByName(arcName);
                    if (arc) arc.visible = e.target.checked;
                });

                // Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒÑ Ğ»Ğ¸Ğ½Ğ¸Ğ¹ Ñ€Ğ°Ğ´Ğ°Ñ€Ğ¾Ğ²
                const radarLines = ['radarLine_0', 'radarLine_90', 'radarLine_180', 'radarLine_270'];
                radarLines.forEach(lineName => {
                    const line = this.scene.getObjectByName(lineName);
                    if (line) line.visible = e.target.checked;
                });
            });

            // Trails toggle
            document.getElementById('showTrails').addEventListener('change', (e) => {
                this.targetTrails.forEach(trail => {
                    trail.visible = e.target.checked;
                });
            });
            }

            setViewMode(mode) {
                switch (mode) {
                    case 'radar':
                        this.camera.position.set(0, 8, 12);
                        this.controls.target.set(0, 0, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'top':
                        this.camera.position.set(0, 25, 0);
                        this.controls.target.set(0, 0, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'side':
                        this.camera.position.set(15, 0, 0);
                        this.controls.target.set(0, 0, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;
                    case 'free':
                        // Keep current position but reset controls
                        this.controls.target.set(0, 0, 0);
                        break;
                }

                // Force controls update
                if (this.controls.updateSpherical) {
                    this.controls.updateSpherical();
                }
                this.controls.update();

                console.log(`ğŸ® Camera view changed to: ${mode}`);
            }

        updateFOV() {
            // Range slider ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ´Ğ»Ğ¸Ğ½Ğ¾Ğ¹ Ğ»Ğ¸Ğ½Ğ¸Ğ¹ Ğ³Ñ€Ğ°Ğ´ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ñ Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
            // Ğ¡Ğ•Ğ¢ĞšĞ£ ĞĞ• Ğ¢Ğ ĞĞ“ĞĞ•Ğœ!

            // ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¸Ğ½Ğ¸Ğ¸ Ğ³Ñ€Ğ°Ğ´ÑƒĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ FOV
            const fovLines = [
                'hFOV_300', 'hFOV_60', 'hFOV_310', 'hFOV_320', 'hFOV_330', 'hFOV_340', 'hFOV_350',
                'hFOV_10', 'hFOV_20', 'hFOV_30', 'hFOV_40', 'hFOV_50',
                'vFOV_0_35', 'vFOV_0_-35', 'vFOV_0_30', 'vFOV_0_-30',
                'vFOV_0_20', 'vFOV_0_-20', 'vFOV_0_10', 'vFOV_0_-10'
            ];

            fovLines.forEach(lineName => {
                const line = this.scene.getObjectByName(lineName);
                if (line) {
                    // ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼ Ğ»Ğ¸Ğ½Ğ¸Ğ¸ Ğ¿Ğ¾ Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½Ñƒ (Ğ½Ğ¾ Ğ½Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ 6Ğ¼)
                    const scale = Math.min(this.radarRange / 6.0, 1.0);
                    line.scale.setScalar(scale);
                }
            });

            // Update FOV indicator
            document.getElementById('fovRange').textContent = `${this.radarRange}m (lines only)`;
        }

            onWindowResize() {
                const container = document.getElementById('radar3d');
                this.camera.aspect = container.clientWidth / container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(container.clientWidth, container.clientHeight);
            }

            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;

                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    console.log('ğŸ”Œ Connected to C.A.R.E. 3D Dashboard');
                    this.updateConnectionStatus(true);
                    if (this.reconnectInterval) {
                        clearInterval(this.reconnectInterval);
                        this.reconnectInterval = null;
                    }
                };

                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };

                this.ws.onclose = () => {
                    console.log('ğŸ”Œ Disconnected from C.A.R.E. 3D Dashboard');
                    this.updateConnectionStatus(false);
                    this.scheduleReconnect();
                };

                this.ws.onerror = (error) => {
                    console.error('âŒ WebSocket error:', error);
                    this.updateConnectionStatus(false);
                };
            }

            scheduleReconnect() {
                if (!this.reconnectInterval) {
                    this.reconnectInterval = setInterval(() => {
                        console.log('ğŸ”„ Attempting to reconnect...');
                        this.connect();
                    }, 5000);
                }
            }

            updateConnectionStatus(connected) {
                const statusEl = document.getElementById('connectionStatus');
                const textEl = document.getElementById('connectionText');

                if (connected) {
                    statusEl.className = 'connection-status connection-connected';
                    textEl.textContent = 'Connected';
                } else {
                    statusEl.className = 'connection-status connection-disconnected';
                    textEl.textContent = 'Disconnected';
                }
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'initial_data':
                        this.updateDashboard(message.data);
                        break;
                    case 'radar':
                        this.updateRadarDisplay(message.data);
                        break;
                    case 'safety':
                        this.updateSafetyStatus(message.data);
                        break;
                    case 'system':
                        this.updateSystemStatus(message.data);
                        break;
                    case 'statistics':
                        this.updateStatistics(message.data);
                        break;
                }
            }

            updateDashboard(data) {
                this.updateRadarDisplay(data.radar);
                this.updateSafetyStatus(data.safety);
                this.updateSystemStatus(data.system);
                this.updateStatistics(data.statistics);
            }

            updateRadarDisplay(radarData) {
                // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ñ†ĞµĞ»ĞµĞ¹
                const activeTargets = radarData.targets ? radarData.targets.filter(t => t.valid) : [];

                // Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑˆĞ»ĞµĞ¹Ñ„Ñ‹ Ğ´Ğ»Ñ Ğ½ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ñ†ĞµĞ»ĞµĞ¹
                this.targetTrails = this.targetTrails.filter(trail => {
                    const targetExists = activeTargets.some(target => target.id === trail.userData.targetId);
                    if (!targetExists) {
                        this.scene.remove(trail);
                        trail.geometry.dispose();
                        trail.material.dispose();
                        return false;
                    }
                    return true;
                });

            // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑˆĞ»ĞµĞ¹Ñ„Ñ‹ Ğ´Ğ»Ñ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ñ†ĞµĞ»ĞµĞ¹
            activeTargets.forEach(target => {
                let trail = this.targetTrails.find(t => t.userData.targetId === target.id);
                if (!trail) {
                    trail = this.createTargetTrail(target.id, target.state);
                        } else {
                    // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ†Ğ²ĞµÑ‚ ÑˆĞ»ĞµĞ¹Ñ„Ğ° ĞµÑĞ»Ğ¸ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»Ğ¾ÑÑŒ
                    if (trail.userData.targetState !== target.state) {
                        trail.userData.targetState = target.state;
                        let trailColor = 0x4CAF50; // Green Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
                        if (target.state === 'safety') {
                            trailColor = 0xff0000; // Red Ğ´Ğ»Ñ safety zone
                        } else if (target.state === 'out_of_fov') {
                            trailColor = 0x0088ff; // Blue Ğ´Ğ»Ñ Ğ²Ğ½Ğµ FOV (6-6.5Ğ¼)
                        } else if (target.state === 'out_of_range') {
                            trailColor = 0x8800ff; // Purple Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ»ĞµÑ‚Ğ° Ğ·Ğ° 6.5Ğ¼
                        }
                        trail.material.color.setHex(trailColor);
                    }
                }

                // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ ÑˆĞ»ĞµĞ¹Ñ„Ğ°
                const targetPosition = {
                    x: target.x / 1000, // ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¼Ğ¼ Ğ² Ğ¼ĞµÑ‚Ñ€Ñ‹
                    y: 0.2, // ĞĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ°Ñ Ğ²Ñ‹ÑĞ¾Ñ‚Ğ° Ğ½Ğ°Ğ´ Ğ·ĞµĞ¼Ğ»ĞµĞ¹
                    z: target.y / 1000
                };
                this.updateTargetTrail(trail, targetPosition);
            });

                // Clear existing targets
                this.targets.forEach(target => {
                    this.scene.remove(target);
                });
                this.targets = [];

                // Update target list
                const targetList = document.getElementById('targetList');
                targetList.innerHTML = '';

                if (activeTargets.length > 0) {
                    activeTargets.forEach((target, index) => {
                        // Create 3D target
                        const targetMesh = this.createTarget(target);
                        this.scene.add(targetMesh);
                        this.targets.push(targetMesh);

                        // Add to list
                        const listItem = document.createElement('div');
                        listItem.className = 'target-item';
                        const distance = Math.sqrt(target.x * target.x + target.y * target.y);
                        let statusClass = 'safe';
                        if (distance < 500) statusClass = 'danger';
                        else if (distance < 1000) statusClass = 'warning';

                        listItem.innerHTML = `
                            <div>
                                <strong>Target ${target.id}</strong>
                                <div class="target-coords">X: ${target.x}mm, Y: ${target.y}mm</div>
                            </div>
                            <div style="color: ${statusClass === 'danger' ? '#ff4444' : statusClass === 'warning' ? '#ffaa00' : '#4CAF50'};">
                                ${Math.round(distance)}mm
                            </div>
                        `;
                        targetList.appendChild(listItem);
                    });
                } else {
                    targetList.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No targets detected</div>';
                }
            }

            createTarget(target) {
                const geometry = new THREE.SphereGeometry(0.2, 16, 12);
                const xMeters = target.x / 1000;
                const yMeters = target.y / 1000;

                // Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ´Ğ¸ÑÑ‚Ğ°Ğ½Ñ†Ğ¸Ñ Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ·Ğ¾Ğ½Ñ‹
                const distance = Math.sqrt(target.x * target.x + target.y * target.y);
                const safetyDistanceMm = 500; // 0.5Ğ¼ Ğ² Ğ¼Ğ¼
                const angleDeg = Math.atan2(target.y, target.x) * 180 / Math.PI;
                const inHorizontalFOV = Math.abs(angleDeg) <= 60;
                const inRange = distance <= 6500; // 6.5Ğ¼
                const outOfFOV = !inHorizontalFOV || !inRange;

                // Ğ¦Ğ²ĞµÑ‚ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ñ†ĞµĞ»Ğ¸ Ğ¸Ğ· Mock CAN
                let color = 0x4CAF50; // Green - Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
                if (target.state === 'safety') {
                    color = 0xff0000; // Red - Ğ² Ğ·Ğ¾Ğ½Ğµ safety
                } else if (target.state === 'out_of_fov') {
                    color = 0x0088ff; // Blue - Ğ²Ğ½Ğµ FOV (6-6.5Ğ¼)
                } else if (target.state === 'out_of_range') {
                    color = 0x8800ff; // Purple - Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ»ĞµÑ‚ Ğ·Ğ° 6.5Ğ¼
                } else {
                    color = 0x4CAF50; // Green - Ğ² FOV
                }

                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });

                const targetMesh = new THREE.Mesh(geometry, material);
                targetMesh.position.set(xMeters, 0.2, yMeters); // Convert mm to m

                // Add animation properties
                targetMesh.userData = {
                    originalTarget: target,
                    state: target.state,
                    animationTime: 0,
                    lastUpdate: Date.now(),
                    createdAt: Date.now(),
                    velocity: {
                        x: (Math.random() - 0.5) * 0.02,
                        y: 0,
                        z: (Math.random() - 0.5) * 0.02
                    },
                    originalScale: targetMesh.scale.clone(),
                    pulsePhase: Math.random() * Math.PI * 2,
                    inSafetyZone: distance < safetyDistanceMm,
                    outOfFOV: outOfFOV,
                    markedForRemoval: false
                };

                return targetMesh;
            }

            // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ÑˆĞ»ĞµĞ¹Ñ„Ğ° Ğ´Ğ»Ñ Ñ†ĞµĞ»Ğ¸
            createTargetTrail(targetId, targetState = 'active') {
                const trailGeometry = new THREE.BufferGeometry();

                // Ğ¦Ğ²ĞµÑ‚ ÑˆĞ»ĞµĞ¹Ñ„Ğ° Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ñ†ĞµĞ»Ğ¸
                let trailColor = 0x4CAF50; // Green Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
                if (targetState === 'safety') {
                    trailColor = 0xff0000; // Red Ğ´Ğ»Ñ safety zone
                } else if (targetState === 'out_of_fov') {
                    trailColor = 0x0088ff; // Blue Ğ´Ğ»Ñ Ğ²Ğ½Ğµ FOV (6-6.5Ğ¼)
                } else if (targetState === 'out_of_range') {
                    trailColor = 0x8800ff; // Purple Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ»ĞµÑ‚Ğ° Ğ·Ğ° 6.5Ğ¼
                }

                const trailMaterial = new THREE.LineBasicMaterial({
                    color: trailColor,
                    transparent: true,
                    opacity: this.trailOpacity,
                    linewidth: 2
                });

                // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¼Ğ°ÑÑĞ¸Ğ² Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹ Ğ´Ğ»Ñ ÑˆĞ»ĞµĞ¹Ñ„Ğ°
                const positions = new Float32Array(this.trailLength * 3);
                trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const trail = new THREE.Line(trailGeometry, trailMaterial);
                trail.userData = {
                    targetId: targetId,
                    targetState: targetState,
                    positions: positions,
                    currentIndex: 0,
                    isFull: false
                };

                this.targetTrails.push(trail);
                this.scene.add(trail);

                return trail;
            }

            // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ÑˆĞ»ĞµĞ¹Ñ„Ğ°
            updateTargetTrail(trail, targetPosition) {
                const { positions, currentIndex, isFull } = trail.userData;

                // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
                positions[currentIndex * 3] = targetPosition.x;
                positions[currentIndex * 3 + 1] = targetPosition.y;
                positions[currentIndex * 3 + 2] = targetPosition.z;

                // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ğ´ĞµĞºÑ
                trail.userData.currentIndex = (currentIndex + 1) % this.trailLength;

                // Ğ•ÑĞ»Ğ¸ ÑˆĞ»ĞµĞ¹Ñ„ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½, Ğ¾Ñ‚Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ ÑÑ‚Ğ¾
                if (!isFull && trail.userData.currentIndex === 0) {
                    trail.userData.isFull = true;
                }

                // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ³ĞµĞ¾Ğ¼ĞµÑ‚Ñ€Ğ¸Ñ
                trail.geometry.attributes.position.needsUpdate = true;
            }

            // ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° ÑˆĞ»ĞµĞ¹Ñ„Ğ° Ñ†ĞµĞ»Ğ¸
            clearTargetTrail(targetId) {
                const trailIndex = this.targetTrails.findIndex(trail => trail.userData.targetId === targetId);
                if (trailIndex !== -1) {
                    const trail = this.targetTrails[trailIndex];
                    this.scene.remove(trail);
                    trail.geometry.dispose();
                    trail.material.dispose();
                    this.targetTrails.splice(trailIndex, 1);
                }
            }

            updateSafetyStatus(safetyData) {
                document.getElementById('emergencyStopStatus').textContent =
                    safetyData.emergencyStop ? 'ACTIVE' : 'Inactive';
                document.getElementById('minDistance').textContent =
                    `${safetyData.minDistance || 500}mm`;
                document.getElementById('activeTargets').textContent =
                    safetyData.activeTargets || 0;
                document.getElementById('lastTrigger').textContent =
                    safetyData.lastTrigger || 'Never';

                // Show/hide emergency panel
                const emergencyPanel = document.getElementById('emergencyPanel');
                if (safetyData.emergencyStop) {
                    emergencyPanel.classList.add('active');
                } else {
                    emergencyPanel.classList.remove('active');
                }
            }

            updateSystemStatus(systemData) {
                document.getElementById('systemStatus').textContent =
                    systemData.status || 'Unknown';
                document.getElementById('systemUptime').textContent =
                    this.formatUptime(systemData.uptime || 0);
                document.getElementById('canMessages').textContent =
                    systemData.canMessages || 0;
                document.getElementById('systemErrors').textContent =
                    systemData.errors || 0;
            }

            updateStatistics(statsData) {
                document.getElementById('messagesPerSecond').textContent =
                    Math.round(statsData.messagesPerSecond || 0);
                document.getElementById('averageLatency').textContent =
                    Math.round(statsData.averageLatency || 0);
            }

            formatUptime(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);

                if (hours > 0) {
                    return `${hours}h ${minutes}m`;
                } else if (minutes > 0) {
                    return `${minutes}m ${secs}s`;
                } else {
                    return `${secs}s`;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const now = Date.now();
                const targetsToRemove = [];

                // Animate targets - Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· Mock CAN Ğ²Ğ¼ĞµÑÑ‚Ğ¾ ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¸
                this.targets.forEach((target, index) => {
                    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ†ĞµĞ»Ğ¸ Ğ¸Ğ· userData.originalTarget
                    const targetData = target.userData.originalTarget;
                    if (targetData) {
                        // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¸Ğ· Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Mock CAN
                        const xMeters = targetData.x / 1000;
                        const yMeters = targetData.y / 1000;
                        target.position.set(xMeters, 0.2, yMeters);

                        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ FOV Ğ¸ Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½
                        const distance = Math.sqrt(targetData.x * targetData.x + targetData.y * targetData.y);
                        const azimuthDeg = Math.atan2(targetData.x, targetData.y) * 180 / Math.PI;
                        const azimuthNorm = ((azimuthDeg % 360) + 360) % 360;
                        const inHorizontalFOV = (azimuthNorm >= 300 || azimuthNorm <= 60);
                        const inRange = distance <= 6500; // 6.5Ğ¼
                        const outOfFOV = !inHorizontalFOV || !inRange;

                        // Ğ•ÑĞ»Ğ¸ Ñ†ĞµĞ»ÑŒ Ğ²Ñ‹ÑˆĞ»Ğ° Ğ·Ğ° Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‹ FOV Ğ¸Ğ»Ğ¸ 6.5Ğ¼ - Ğ¾ĞºÑ€Ğ°ÑĞ¸Ñ‚ÑŒ Ğ² ÑĞ¸Ğ½Ğ¸Ğ¹
                        if (outOfFOV && !target.userData.outOfFOV) {
                            target.material.color.setHex(0x0088ff); // Blue
                            target.userData.outOfFOV = true;
                            target.userData.outOfFOVTime = now;
                        }

                        // Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ½Ğ¸Ğµ Ñ†ĞµĞ»Ğ¸ Ñ‡ĞµÑ€ĞµĞ· 1 ÑĞµĞºÑƒĞ½Ğ´Ñƒ
                        if (target.userData.outOfFOV && (now - target.userData.outOfFOVTime > 1000)) {
                            target.userData.markedForRemoval = true;
                        }

                        // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ†Ğ²ĞµÑ‚ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ safety Ğ·Ğ¾Ğ½Ñ‹
                        if (!outOfFOV) {
                            const distanceMm = distance;
                            const safetyDistanceMm = (this.safetyDistance || 0.5) * 1000;
                            if (distanceMm < safetyDistanceMm) {
                                target.material.color.setHex(0xff0000); // Red - Ğ² safety Ğ·Ğ¾Ğ½Ğµ
                            } else if (distanceMm < safetyDistanceMm * 2) {
                                target.material.color.setHex(0xffaa00); // Orange - Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ
                            } else {
                                target.material.color.setHex(0x4CAF50); // Green - Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾
                            }
                        }

                        // ĞŸĞ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¿ÑƒĞ»ÑŒÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
                        const time = now * 0.002; // ĞœĞµĞ´Ğ»ĞµĞ½Ğ½ĞµĞµ
                        const scale = 1 + Math.sin(time + target.userData.pulsePhase) * 0.2; // ĞœĞµĞ½ÑŒÑˆĞµ Ğ°Ğ¼Ğ¿Ğ»Ğ¸Ñ‚ÑƒĞ´Ğ°
                        target.scale.setScalar(scale);
                    }

                    // Mark for removal if flagged
                    if (target.userData.markedForRemoval) {
                        targetsToRemove.push(index);
                    }
                });

                // Remove marked targets
                for (let i = targetsToRemove.length - 1; i >= 0; i--) {
                    const index = targetsToRemove[i];
                    this.scene.remove(this.targets[index]);
                    this.targets.splice(index, 1);
                }

                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new Care3DDashboard();
        });
    </script>
</body>
</html>
